// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using NuGet.Common;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;

namespace NuGet.Protocol
{
    public class VulnerabilityInfoResource : INuGetResource
    {
        private readonly HttpSource _client;
        private readonly Uri _vulnerabilityEndpoint;
        private readonly ServiceIndexEntry _vulnerabilityServiceIndexEntry;
        private readonly object _lock = new();

        private AsyncLazy<bool> _ensurePackageVulnerabilitiesInfoAsyncTask;
        private Dictionary<string, List<NuGetVersion>> _vulnerablePackages;

        public VulnerabilityInfoResource(HttpSource client, ServiceIndexEntry vulnerabilityServiceIndexEntry)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _vulnerabilityServiceIndexEntry = vulnerabilityServiceIndexEntry ?? throw new ArgumentNullException(nameof(vulnerabilityServiceIndexEntry));
            _vulnerabilityEndpoint = vulnerabilityServiceIndexEntry.Uri;
        }

        public async Task<bool> IsPackageVulnerableAsync(
            string id,
            NuGetVersion version,
            ILogger log,
            CancellationToken cancellationToken)
        {
            // Can we load too much vulnerability data? Is that a risk we should account for?
            if (id == null) throw new ArgumentNullException(nameof(id));
            if (version == null) throw new ArgumentNullException(nameof(version));
            if (log == null) throw new ArgumentNullException(nameof(log));

            lock (_lock)
            {
                if (_ensurePackageVulnerabilitiesInfoAsyncTask == null)
                { // TODO NK - Add a means to refresh the cache.
                    _ensurePackageVulnerabilitiesInfoAsyncTask = new AsyncLazy<bool>(() => EnsurePackageVulnerabilitiesInfoAsync(log, cancellationToken));
                }
            }

            await _ensurePackageVulnerabilitiesInfoAsyncTask;

            if (_vulnerablePackages.TryGetValue(id, out var versionList) && versionList.Contains(version))
            {
                return true;
            }
            return false;
        }

        private async Task<bool> EnsurePackageVulnerabilitiesInfoAsync(ILogger log, CancellationToken cancellationToken)
        {
            var cacheKey = GenerateCacheKey(_vulnerabilityServiceIndexEntry);

            const int maxRetries = 3;
            for (var retry = 1; retry <= maxRetries; retry++)
            {
                using (var sourceCacheContext = new SourceCacheContext())
                {
                    var httpSourceCacheContext = HttpSourceCacheContext.Create(sourceCacheContext, isFirstAttempt: retry == 1);

                    try
                    {
                        _vulnerablePackages = await GetVulnerabilityInformationAsync(
                        (httpSource, uri) => httpSource.GetAsync(
                            request: new HttpSourceCachedRequest(
                                        uri.AbsoluteUri,
                                        cacheKey,
                                        httpSourceCacheContext)
                            {
                                EnsureValidContents = stream => HttpStreamValidation.ValidateJObject(_vulnerabilityEndpoint.AbsoluteUri, stream),
                                MaxTries = 1,
                                IsRetry = retry > 1,
                                IsLastAttempt = retry == maxRetries
                            },
                            processAsync: async httpSourceResult =>
                            {
                                return await ProcessStream(httpSourceResult.Stream, cancellationToken);
                            },
                            log: log,
                            token: cancellationToken),
                        log,
                        cancellationToken);
                        break;
                    }
                    catch (Exception ex) when (retry < maxRetries)
                    {
                        var message = string.Format(CultureInfo.CurrentCulture, "TODO NK - Strings.Log_RetryingRepositorySignature", _vulnerabilityEndpoint.AbsoluteUri)
                            + Environment.NewLine
                            + ExceptionUtilities.DisplayMessage(ex);
                        log.LogMinimal(message);
                    }
                    catch (Exception ex) when (retry == maxRetries)
                    {
                        var message = string.Format(CultureInfo.CurrentCulture, "TODO NK - Strings.Log_FailedToReadRepositorySignature", _vulnerabilityEndpoint.AbsoluteUri);

                        throw new FatalProtocolException(message, ex);
                    }
                }
            }
            return true;
            static string GenerateCacheKey(ServiceIndexEntry serviceEntry)
            {
#if NETCOREAPP
            var index = serviceEntry.Type.IndexOf('/', StringComparison.Ordinal);
#else
                var index = serviceEntry.Type.IndexOf('/');
#endif
                var version = serviceEntry.Type.Substring(index + 1).Trim();

                return $"vulnerability_info_{version}";
            }
        }

        private async Task<T> GetVulnerabilityInformationAsync<T>(
            Func<HttpSource, Uri, Task<T>> getResultAsync,
            ILogger log,
            CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var endpoint = _vulnerabilityEndpoint;

            var queryUrl = new UriBuilder(endpoint.AbsoluteUri);

            T searchResult;
            try
            {
                log.LogVerbose($"Querying {queryUrl.Uri}");

                searchResult = await getResultAsync(_client, queryUrl.Uri);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (JsonReaderException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_MalformedMetadataError, queryUrl.Uri), ex);
            }
            catch (HttpRequestException ex)
            {
                throw new FatalProtocolException(string.Format(CultureInfo.CurrentCulture, Strings.Protocol_BadSource, queryUrl.Uri), ex);
            }

            if (searchResult != null)
            {
                return searchResult;
            }

            throw new FatalProtocolException("Something went really really really wrong :D");
        }


        private Task<Dictionary<string, List<NuGetVersion>>> ProcessStream(Stream stream, CancellationToken token)
        {
            var _newtonsoftConvertersSerializer = JsonSerializer.Create(JsonExtensions.ObjectSerializationSettings);

            using var streamReader = new StreamReader(stream);
            using var jsonReader = new JsonTextReader(streamReader);
            var packageVulnerabilities = _newtonsoftConvertersSerializer.Deserialize<VulnerabilityResults>(jsonReader).Data;

            return Task.FromResult(GenerateVulnerabilityMap(packageVulnerabilities));

            static Dictionary<string, List<NuGetVersion>> GenerateVulnerabilityMap(List<PackageMetadata> packageVulnerabilities)
            {
                Dictionary<string, List<NuGetVersion>> vulnerablePackages = new();
                if (vulnerablePackages != null)
                {
                    foreach (var entry in packageVulnerabilities)
                    {
                        if (vulnerablePackages.ContainsKey(entry.Id))
                        {
                            vulnerablePackages[entry.Id].Add(entry.Version);
                        }
                        else
                        {
                            vulnerablePackages.Add(entry.Id, new List<NuGetVersion>() { entry.Version });
                        }
                    }
                }

                return vulnerablePackages;
            }
        }

        internal class VulnerabilityResults
        {
            [JsonProperty("data")]
            public List<PackageMetadata> Data { get; private set; } = new List<PackageMetadata>();
        }

        internal class PackageMetadata
        {
            [JsonProperty(PropertyName = JsonProperties.SubjectId)]
            [JsonConverter(typeof(MetadataFieldConverter))]
            public string Id { get; private set; }

            [JsonProperty(PropertyName = JsonProperties.Version)]
            public NuGetVersion Version { get; private set; }

            [JsonProperty(PropertyName = "severity")]
            public int Severity { get; private set; }

            [JsonProperty(PropertyName = "advisoryUrl")]
            public Uri AdvisoryUrl { get; private set; }
        }
    }
}
